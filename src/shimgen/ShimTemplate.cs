using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

public class ShimArgs
{
    // All field names must start from shimgen_ just to avoid conflicting with application command line arguments
    public string shimgen_exepath;
    public bool shimgen_help;
    public bool shimgen_log;
    public bool shimgen_waitforexit;
    public bool shimgen_info;
    public bool shimgen_exit;       //alias for "info"
    public bool shimgen_gui;
    public bool shimgen_usetargetworkingdirectory;
    public bool shimgen_noop;
}


public class ShimTemplate
{
    static Action<string> log = (s) => { };

    static void enableLog()
    { 
        log = (s) => { Console.WriteLine(s); };
    }

    // https://learn.microsoft.com/en-us/windows/console/setconsolectrlhandler?WT.mc_id=DT-MVP-5003978
    [DllImport("Kernel32")]
    private static extern bool SetConsoleCtrlHandler(SetConsoleCtrlEventHandler handler, bool add);

    private enum CtrlType
    {
        CTRL_C_EVENT = 0,
        CTRL_BREAK_EVENT = 1,
        CTRL_CLOSE_EVENT = 2,
        CTRL_LOGOFF_EVENT = 5,
        CTRL_SHUTDOWN_EVENT = 6
    }

    // https://learn.microsoft.com/en-us/windows/console/handlerroutine?WT.mc_id=DT-MVP-5003978
    private delegate bool SetConsoleCtrlEventHandler(CtrlType sig);

    static Process proc;
    
    public static int ShimMain(string[] args, ShimArgs shimargs)
    {
        List<string> remainingArgs = new List<string>();
        ShimArgs cmdArgs = CmdArgs.Parse<ShimArgs>(args, false, shimargs, remainingArgs);
        if (cmdArgs.shimgen_exit) cmdArgs.shimgen_info = true;


        //for debugging purposes only, comment out for release
        //cmdArgs.shimgen_log = true;

        if (cmdArgs.shimgen_log || cmdArgs.shimgen_noop || cmdArgs.shimgen_info)
        {
            enableLog();
        }

        string shimExeDir = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
        string exepath = cmdArgs.shimgen_exepath;
        if (!Path.IsPathRooted(exepath))
        {
            exepath = Path.GetFullPath(Path.Combine(shimExeDir, exepath));
        }
        bool gui = cmdArgs.shimgen_gui;
        bool waitForExit = (cmdArgs.shimgen_waitforexit) ? true: !gui;

        log($"exepath: {exepath} (gui: {gui})");
        log($"waitForExit: {waitForExit}");
        string cmdLine = String.Join(" ", remainingArgs);
        log($"cmdLine: '{cmdLine}'");
        string workdir = Environment.CurrentDirectory;
        if (cmdArgs.shimgen_usetargetworkingdirectory)
        {
            workdir = shimExeDir;
        }
        log($"workdir: '{workdir}'");
        if (cmdArgs.shimgen_info)
        {
            log($"shim exited (-{nameof(ShimArgs.shimgen_info)} requested)");
            return 0;
        }
        
        if (cmdArgs.shimgen_help)
        {
            enableLog();
            log("this executable was generated by ShimGen");
            log("");
            log("this executable will execute following exe:");
            log($"  exepath: {exepath}");
            if (!File.Exists(exepath)) log("  WARNING: file does not exists");
            log($"  workdir: {workdir}");
            log($"  is gui: {gui.ToString().ToLower()}");
            log("");
            log("shim arguments:");
            log("---------------");
            log($"  -{nameof(ShimArgs.shimgen_help)}                        - show this help");
            log($"  -{nameof(ShimArgs.shimgen_log)}                         - logging is shown on command line");
            log($"  -{nameof(ShimArgs.shimgen_waitforexit)}                 - waits for main executable exit");
            log($"  -{nameof(ShimArgs.shimgen_info)}                        - shows information on specific shim");
            log($"  -{nameof(ShimArgs.shimgen_gui)}                         - launch target exe as gui");
            log($"  -{nameof(ShimArgs.shimgen_usetargetworkingdirectory)}   - use target exe working directory");
            log($"  -{nameof(ShimArgs.shimgen_noop)}                        - does not runs the target");
            log("");
            return 0;
        }

        if (cmdArgs.shimgen_noop)
        {
            log($"shim exited (-{nameof(ShimArgs.shimgen_noop)} requested)");
            return 0;
        }

        if (!File.Exists(exepath))
        {
            Console.WriteLine($"Error: Executable does not exists: '{exepath}'");
            return -1;
        }

        SetConsoleCtrlHandler(CtrlHandler, true);
        log($"executing '{exepath}' '{cmdLine}'");

        bool requiresElevation = false;

        for(int iTry = 0; iTry < 2; iTry++)
        {
            try
            {
                proc = new Process()
                {
                    StartInfo = new ProcessStartInfo(exepath, cmdLine)
                    {
                        WorkingDirectory = workdir,
                        WindowStyle = ProcessWindowStyle.Minimized
                    }
                };

                if (requiresElevation)
                {
                    log("elevating process");
                    var startInfo = proc.StartInfo;
                    startInfo.UseShellExecute = true;
                    startInfo.Verb = "runas";
                    startInfo.WindowStyle = ProcessWindowStyle.Normal;
                }

                proc.Start();
                if (waitForExit)
                {
                    proc.WaitForExit();
                    if (proc.HasExited)
                    {
                        log($"target process exited, exit code: {proc.ExitCode}");
                        return proc.ExitCode;
                    }
                }
                else
                {
                    // Don't start for second time.
                    return 0;
                }
            }
            catch (Win32Exception wex)
            {
                if (wex.NativeErrorCode == 1223)
                { 
                    log("User cancelled elevation");
                    return wex.NativeErrorCode;
                }
                
                if (wex.NativeErrorCode != 740)
                {
                    log($"target process cannot be started, exit code: {wex.NativeErrorCode}");
                    return wex.NativeErrorCode;
                }

                log("Process needs elevation, retrying for second time");
                requiresElevation = true;
            }
        }

        return -3;
    }


    private static bool CtrlHandler(CtrlType signal)
    {
        log($"shim: received signal {signal.ToString()}, aborting");
        int exitCode = -1;

        try
        {
            if (proc != null && !proc.HasExited)
            {
                proc.Kill();
            }
            
            if((proc != null && proc.HasExited)) exitCode = proc.ExitCode;
        }
        catch(Exception ex)
        {
            log($"error when trying to kill process: {ex.Message}");
        }

        Environment.Exit(exitCode);
        return false;
    }
}
